// Copyright (C) 1991-2016 Altera Corporation. All rights reserved.
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, the Altera Quartus Prime License Agreement,
// the Altera MegaCore Function License Agreement, or other 
// applicable license agreement, including, without limitation, 
// that your use is for the sole purpose of programming logic 
// devices manufactured by Altera and sold by Altera or its 
// authorized distributors.  Please refer to the applicable 
// agreement for further details.

// VENDOR "Altera"
// PROGRAM "Quartus Prime"
// VERSION "Version 16.0.0 Build 211 04/27/2016 SJ Lite Edition"

// DATE "10/24/2021 22:25:24"

// 
// Device: Altera EP4CE115F29C7 Package FBGA780
// 

// 
// This Verilog file should be used for ModelSim-Altera (Verilog) only
// 

`timescale 1 ps/ 1 ps

module control (
	opcode,
	DMwe,
	Rwe,
	Rwd,
	Rdst,
	ALUinB,
	is_Rtype,
	is_addi,
	is_lw,
	is_sw);
input 	[4:0] opcode;
output 	DMwe;
output 	Rwe;
output 	Rwd;
output 	Rdst;
output 	ALUinB;
output 	is_Rtype;
output 	is_addi;
output 	is_lw;
output 	is_sw;

wire gnd;
wire vcc;
wire unknown;

assign gnd = 1'b0;
assign vcc = 1'b1;
assign unknown = 1'bx;

tri1 devclrn;
tri1 devpor;
tri1 devoe;
wire \DMwe~output_o ;
wire \Rwe~output_o ;
wire \Rwd~output_o ;
wire \Rdst~output_o ;
wire \ALUinB~output_o ;
wire \is_Rtype~output_o ;
wire \is_addi~output_o ;
wire \is_lw~output_o ;
wire \is_sw~output_o ;
wire \opcode[1]~input_o ;
wire \opcode[0]~input_o ;
wire \opcode[2]~input_o ;
wire \opcode[3]~input_o ;
wire \opcode[4]~input_o ;
wire \is_sw~0_combout ;
wire \is_sw~1_combout ;
wire \is_lw~0_combout ;
wire \Rwe~0_combout ;
wire \is_lw~1_combout ;
wire \is_Rtype~0_combout ;
wire \is_addi~0_combout ;


cycloneive_io_obuf \DMwe~output (
	.i(\is_sw~1_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\DMwe~output_o ),
	.obar());
// synopsys translate_off
defparam \DMwe~output .bus_hold = "false";
defparam \DMwe~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_obuf \Rwe~output (
	.i(\Rwe~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\Rwe~output_o ),
	.obar());
// synopsys translate_off
defparam \Rwe~output .bus_hold = "false";
defparam \Rwe~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_obuf \Rwd~output (
	.i(\is_lw~1_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\Rwd~output_o ),
	.obar());
// synopsys translate_off
defparam \Rwd~output .bus_hold = "false";
defparam \Rwd~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_obuf \Rdst~output (
	.i(!\is_Rtype~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\Rdst~output_o ),
	.obar());
// synopsys translate_off
defparam \Rdst~output .bus_hold = "false";
defparam \Rdst~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_obuf \ALUinB~output (
	.i(\is_Rtype~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\ALUinB~output_o ),
	.obar());
// synopsys translate_off
defparam \ALUinB~output .bus_hold = "false";
defparam \ALUinB~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_obuf \is_Rtype~output (
	.i(!\is_Rtype~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\is_Rtype~output_o ),
	.obar());
// synopsys translate_off
defparam \is_Rtype~output .bus_hold = "false";
defparam \is_Rtype~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_obuf \is_addi~output (
	.i(\is_addi~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\is_addi~output_o ),
	.obar());
// synopsys translate_off
defparam \is_addi~output .bus_hold = "false";
defparam \is_addi~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_obuf \is_lw~output (
	.i(\is_lw~1_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\is_lw~output_o ),
	.obar());
// synopsys translate_off
defparam \is_lw~output .bus_hold = "false";
defparam \is_lw~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_obuf \is_sw~output (
	.i(\is_sw~1_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\is_sw~output_o ),
	.obar());
// synopsys translate_off
defparam \is_sw~output .bus_hold = "false";
defparam \is_sw~output .open_drain_output = "false";
// synopsys translate_on

cycloneive_io_ibuf \opcode[1]~input (
	.i(opcode[1]),
	.ibar(gnd),
	.o(\opcode[1]~input_o ));
// synopsys translate_off
defparam \opcode[1]~input .bus_hold = "false";
defparam \opcode[1]~input .simulate_z_as = "z";
// synopsys translate_on

cycloneive_io_ibuf \opcode[0]~input (
	.i(opcode[0]),
	.ibar(gnd),
	.o(\opcode[0]~input_o ));
// synopsys translate_off
defparam \opcode[0]~input .bus_hold = "false";
defparam \opcode[0]~input .simulate_z_as = "z";
// synopsys translate_on

cycloneive_io_ibuf \opcode[2]~input (
	.i(opcode[2]),
	.ibar(gnd),
	.o(\opcode[2]~input_o ));
// synopsys translate_off
defparam \opcode[2]~input .bus_hold = "false";
defparam \opcode[2]~input .simulate_z_as = "z";
// synopsys translate_on

cycloneive_io_ibuf \opcode[3]~input (
	.i(opcode[3]),
	.ibar(gnd),
	.o(\opcode[3]~input_o ));
// synopsys translate_off
defparam \opcode[3]~input .bus_hold = "false";
defparam \opcode[3]~input .simulate_z_as = "z";
// synopsys translate_on

cycloneive_io_ibuf \opcode[4]~input (
	.i(opcode[4]),
	.ibar(gnd),
	.o(\opcode[4]~input_o ));
// synopsys translate_off
defparam \opcode[4]~input .bus_hold = "false";
defparam \opcode[4]~input .simulate_z_as = "z";
// synopsys translate_on

cycloneive_lcell_comb \is_sw~0 (
// Equation(s):
// \is_sw~0_combout  = (\opcode[0]~input_o  & (\opcode[2]~input_o  & (!\opcode[3]~input_o  & !\opcode[4]~input_o )))

	.dataa(\opcode[0]~input_o ),
	.datab(\opcode[2]~input_o ),
	.datac(\opcode[3]~input_o ),
	.datad(\opcode[4]~input_o ),
	.cin(gnd),
	.combout(\is_sw~0_combout ),
	.cout());
// synopsys translate_off
defparam \is_sw~0 .lut_mask = 16'h0008;
defparam \is_sw~0 .sum_lutc_input = "datac";
// synopsys translate_on

cycloneive_lcell_comb \is_sw~1 (
// Equation(s):
// \is_sw~1_combout  = (\opcode[1]~input_o  & \is_sw~0_combout )

	.dataa(\opcode[1]~input_o ),
	.datab(\is_sw~0_combout ),
	.datac(gnd),
	.datad(gnd),
	.cin(gnd),
	.combout(\is_sw~1_combout ),
	.cout());
// synopsys translate_off
defparam \is_sw~1 .lut_mask = 16'h8888;
defparam \is_sw~1 .sum_lutc_input = "datac";
// synopsys translate_on

cycloneive_lcell_comb \is_lw~0 (
// Equation(s):
// \is_lw~0_combout  = (!\opcode[1]~input_o  & (!\opcode[0]~input_o  & (!\opcode[2]~input_o  & !\opcode[4]~input_o )))

	.dataa(\opcode[1]~input_o ),
	.datab(\opcode[0]~input_o ),
	.datac(\opcode[2]~input_o ),
	.datad(\opcode[4]~input_o ),
	.cin(gnd),
	.combout(\is_lw~0_combout ),
	.cout());
// synopsys translate_off
defparam \is_lw~0 .lut_mask = 16'h0001;
defparam \is_lw~0 .sum_lutc_input = "datac";
// synopsys translate_on

cycloneive_lcell_comb \Rwe~0 (
// Equation(s):
// \Rwe~0_combout  = (\is_lw~0_combout ) # ((\is_sw~0_combout  & !\opcode[1]~input_o ))

	.dataa(\is_lw~0_combout ),
	.datab(\is_sw~0_combout ),
	.datac(gnd),
	.datad(\opcode[1]~input_o ),
	.cin(gnd),
	.combout(\Rwe~0_combout ),
	.cout());
// synopsys translate_off
defparam \Rwe~0 .lut_mask = 16'hAAEE;
defparam \Rwe~0 .sum_lutc_input = "datac";
// synopsys translate_on

cycloneive_lcell_comb \is_lw~1 (
// Equation(s):
// \is_lw~1_combout  = (\opcode[3]~input_o  & \is_lw~0_combout )

	.dataa(\opcode[3]~input_o ),
	.datab(\is_lw~0_combout ),
	.datac(gnd),
	.datad(gnd),
	.cin(gnd),
	.combout(\is_lw~1_combout ),
	.cout());
// synopsys translate_off
defparam \is_lw~1 .lut_mask = 16'h8888;
defparam \is_lw~1 .sum_lutc_input = "datac";
// synopsys translate_on

cycloneive_lcell_comb \is_Rtype~0 (
// Equation(s):
// \is_Rtype~0_combout  = (\opcode[3]~input_o ) # (!\is_lw~0_combout )

	.dataa(\opcode[3]~input_o ),
	.datab(gnd),
	.datac(gnd),
	.datad(\is_lw~0_combout ),
	.cin(gnd),
	.combout(\is_Rtype~0_combout ),
	.cout());
// synopsys translate_off
defparam \is_Rtype~0 .lut_mask = 16'hAAFF;
defparam \is_Rtype~0 .sum_lutc_input = "datac";
// synopsys translate_on

cycloneive_lcell_comb \is_addi~0 (
// Equation(s):
// \is_addi~0_combout  = (\is_sw~0_combout  & !\opcode[1]~input_o )

	.dataa(\is_sw~0_combout ),
	.datab(gnd),
	.datac(gnd),
	.datad(\opcode[1]~input_o ),
	.cin(gnd),
	.combout(\is_addi~0_combout ),
	.cout());
// synopsys translate_off
defparam \is_addi~0 .lut_mask = 16'h00AA;
defparam \is_addi~0 .sum_lutc_input = "datac";
// synopsys translate_on

assign DMwe = \DMwe~output_o ;

assign Rwe = \Rwe~output_o ;

assign Rwd = \Rwd~output_o ;

assign Rdst = \Rdst~output_o ;

assign ALUinB = \ALUinB~output_o ;

assign is_Rtype = \is_Rtype~output_o ;

assign is_addi = \is_addi~output_o ;

assign is_lw = \is_lw~output_o ;

assign is_sw = \is_sw~output_o ;

endmodule
